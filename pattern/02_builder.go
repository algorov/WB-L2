package pattern

import "fmt"

/*
	Реализовать паттерн «строитель».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Builder_pattern


	Паттерн, пораждающий объекты. Паттерн проектирования Builder разработан для обеспечения гибкого решения различных задач создания объектов в объектно-ориентированном программировании.
	Отделяет конструирование сложного объекта от его представления.
	В результате одного и того же процесса конструирования могут получаться разные представления.
	Строитель не создает объекты самостоятельно, его основная цель - просто определить интерфейс для создания объектов.
	Реальную работу выполняют подклассы строителя поэтапным подходом.

	Плюсы:
		1. Разделение сложного объекта;
		2. Гибкость;
		3. Код становится более читаемым.

	Минусы:
		1. Увеличение кода;
		2. Сложность добавления новых компонентов;
		3. Необходимость создания отдельных строителей;
		4. Зависимость от порядка строительства.

	Применяется, когда необходимо создавать сложные объекты с большим количеством опциональных параметров.
*/

// Объект, который будет собирараться.
type Car struct {
	/*...*/
}

// Представление строителя.
type Builder interface {
	SetMark()
	SetModel()
	SetPrice()
}

// Конструирование представление строителя.
type CarBuilder struct {
	/*...*/
}

// Реализация необходимого метода.
func (c *CarBuilder) SetMark() {
	fmt.Println("SetMark")
}

// Реализация необходимого метода.
func (c *CarBuilder) SetModel() {
	fmt.Println("SetModel")
}

// Реализация необходимого метода.
func (c *CarBuilder) SetPrice() {
	fmt.Println("SetPrice")
}

// Распорядитель.
type CarEngineer struct {
	builder Builder
}

// Создание распорядителя.
func NewEngineer(builder Builder) *CarEngineer {
	return &CarEngineer{
		builder: builder,
	}
}

// Сборка объекта и предоставление клиенту.
func (c *CarEngineer) Build() *Car {
	/*...*/
}
