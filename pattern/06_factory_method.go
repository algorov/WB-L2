package pattern

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern

Пораждающий паттерн проектирования. Актуален, когда нужно клиентский код от реализации.

Предназначение:
* классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
* класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.
* класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя.

Достоинста:
* позволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам (ConcreteProduct), а оперируя лишь общим интерфейсом (Product);
* позволяет установить связь между параллельными иерархиями классов.

Недостатки:
* необходимость создавать наследника Creator для каждого нового типа продукта (ConcreteProduct).

*/

// Контракт продукта.
type Product interface {
	Exec()
}

// Конкретная реализующая структура.
type ProductA struct {
}

// Реализация сигнатуры.
func (p ProductA) Exec() {
	// *** //
}

// Конкретная реализующая структура.
type ProductB struct {
}

// Реализация сигнатуры.
func (p ProductB) Exec() {
	// *** //
}

// Интерфейс создателя продукта.
type Creator interface {
	CreateProduct() Product
}

// Реализация создателей.
type ProductACreator struct {
}

// Реализация сигнатуры.
func (p *ProductACreator) CreateProduct() Product {
	return ProductA{}
}

type ProductBCreator struct {
}

// Реализация сигнатуры.
func (p *ProductBCreator) CreateProduct() Product {
	return ProductA{}
}
