package pattern

import "fmt"

/*
	Реализовать паттерн «состояние».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/State_pattern

	State (состояние) - это поведенческий паттерн проектирования, который позволяет объекту изменять свое поведение в зависимости от своего внутреннего состояния.
	Этот паттерн относится к категории паттернов поведения, потому что он решает проблемы управления состоянием объекта и его поведением.

	Предположим, у вас есть объект Context, который представляет состояние работы некоторого процесса.
	Этот процесс может находиться в различных состояниях, таких как "запущен", "приостановлен", "завершен".
	Вместо того чтобы включать в Context логику для каждого из этих состояний, мы можем создать отдельные классы State для каждого состояния и делегировать им выполнение операций.

	Плюсы:
		 * Явное разделение обязанностей.
		 * Упрощение логики (не нужно много if-ов).
		 * Масштабирование.
		 * Код удобен для тестирования.

	Минусы:
		* Увеличение числа структур (классов)
		* Если мало состояний, то это скорее усложнит понимание кода.


*/

// Сам интерфейс.
type State interface {
	Start()
	Pause()
	Stop()
}

// Конкретная реализация состояния.
type StartedState struct{}

func (s *StartedState) Start() {
	fmt.Println("Запушен")
}

func (s *StartedState) Pause() {
	fmt.Println("Приостановлен")
}

func (s *StartedState) Stop() {
	fmt.Println("Остановлен")
}

// Конкретная реализация состояния.
type PausedState struct{}

func (s *PausedState) Start() {
	fmt.Println("Запушен")
}

func (s *PausedState) Pause() {
	fmt.Println("Приостановлен")
}

func (s *PausedState) Stop() {
	fmt.Println("Остановлен")
}

// Сам контекст, который хранит в себе состояние.
type Process struct {
	state State
}

func (p *Process) setState(state State) {
	p.state = state
}

func (p *Process) Start() {
	p.state.Start()
}

func (p *Process) Pause() {
	p.state.Pause()
}

func (p *Process) Stop() {
	p.state.Stop()
}
